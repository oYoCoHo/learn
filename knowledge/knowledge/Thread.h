/*

线程安全：
1.在多线程下，对象的属性赋值不是原子性的
2.在多线程下，可变数组和可变字典是线程不安全的
3.线程锁通过懒加载的方式生成，在子线程加锁，如果初始多次调用方法，因为子线程生产锁实例导致加锁崩溃
4.死锁
5.优先级反转（自旋锁）

死锁：
1.一个线程中，加锁后没有释放锁再次进行加锁
2.线程锁的优先级反转
3.队列死锁，在当前队列中同步执行该队列任务
4.队列相互依赖


优先级反转：
1.不同级别的任务存在依赖关系，避免不同优先级任务之间的依赖，调整任务的优先级
2.高优先级线程等待低优先级线程，低优先级线程被阻塞了

1.自旋锁和信号量dispatch_semaphore_t都有优先级反转问题，因为不知道持有者，锁被哪个线程持有
2.为了避免优先级反转问题，需要知道线程锁被那个线程持有，提高持有锁线程的优先级，把持有锁的优先级提升到等待线程的优先级

NSLock，dispatch queue 和 pthread mutex 通过自动提高持有锁线程的优先级解决优先级反转问题。 由于信号量（如，dispatch_semaphore_t）不知道哪个线程正在执行工作，其不会进行类似处理。

“饥饿”策略的原理是通过修改线程的优先级来实现的。NSLock会检查等待线程的优先级是否高于持有锁的线程的优先级。如果是，NSLock会将持有锁的线程的优先级提升到等待线程的优先级，以避免优先级反转问题的出现。

dispatch_semaphore 会造成优先级反转，慎用
https://blog.51cto.com/u_15064655/2573045

互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
自旋锁加锁失败后，线程会忙等待，直到它拿到锁

队列死锁的情况
1.主线程中调用主队列
2.同步执行所在队列

队列：
1.任务的优先级比队列优先级高,所以我们在队列和任务的各种组合的时候,首先要看我们的任务.
2.异步才有开辟线程的能力,同步没有开辟线程的能力，异步是在其它线程上执行,同步,在当前线程上执行


*/
